#SYMMETRIC CIPHERS
#HOW AES WORKS
#Structure of AES
#crypto{inmatrix}
def bytes2matrix(text):
    """ Converts a 16-byte array into a 4x4 matrix.  """
    return [list(text[i:i+4]) for i in range(0, len(text), 4)]

def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array.  """
    return bytes(sum(matrix, []))

matrix = [
    [99, 114, 121, 112],
    [116, 111, 123, 105],
    [110, 109, 97, 116],
    [114, 105, 120, 125],
]

print(str(matrix2bytes(matrix).decode('utf-8')))
----------------------------------------------------------------------------
#Round Keys
state = [
    [206, 243, 61, 34],
    [171, 11, 93, 31],
    [16, 200, 91, 108],
    [150, 3, 194, 51],
]

round_key = [
    [173, 129, 68, 82],
    [223, 100, 38, 109],
    [32, 189, 53, 8],
    [253, 48, 187, 78],
]

def add_round_key(s, k):
    return [[sss^kkk for sss, kkk in zip(ss, kk)] for ss, kk in zip(s, k)]

print(add_round_key(state, round_key))

#Confusion through Substitution
#crypto{l1n34rly}
s_box = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

inv_s_box = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

state = [
    [251, 64, 182, 81],
    [146, 168, 33, 80],
    [199, 159, 195, 24],
    [64, 80, 182, 255],
]
def sub_bytes(s, sbox=s_box):
    return bytes(sum([[sbox[e] for e in r] for r in s], []))
print(sub_bytes(state, sbox=inv_s_box))

#Diffusion through Permutation
def shift_rows(s):
    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]
    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]
    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]


def inv_shift_rows(s):
    s[1][1], s[2][1], s[3][1], s[0][1] = s[0][1], s[1][1], s[2][1], s[3][1]
    s[2][2], s[3][2], s[0][2], s[1][2] = s[0][2], s[1][2], s[2][2], s[3][2]
    s[3][3], s[0][3], s[1][3], s[2][3] = s[0][3], s[1][3], s[2][3], s[3][3]


# learned from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)


def mix_single_column(a):
    # see Sec 4.1.2 in The Design of Rijndael
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ xtime(a[0] ^ a[1])
    a[1] ^= t ^ xtime(a[1] ^ a[2])
    a[2] ^= t ^ xtime(a[2] ^ a[3])
    a[3] ^= t ^ xtime(a[3] ^ u)


def mix_columns(s):
    for i in range(4):
        mix_single_column(s[i])


def inv_mix_columns(s):
    # see Sec 4.1.3 in The Design of Rijndael
    for i in range(4):
        u = xtime(xtime(s[i][0] ^ s[i][2]))
        v = xtime(xtime(s[i][1] ^ s[i][3]))
        s[i][0] ^= u
        s[i][1] ^= v
        s[i][2] ^= u
        s[i][3] ^= v

    mix_columns(s)


state = [
    [108, 106, 71, 86],
    [96, 62, 38, 72],
    [42, 184, 92, 209],
    [94, 79, 8, 54],
]

inv_mix_columns(state)
inv_shift_rows(state)
print(bytes(sum(state, [])))

#Bringing It All Together
#crypto{MYAES128}
N_ROUNDS = 10

key        = b'\xc3,\\\xa6\xb5\x80^\x0c\xdb\x8d\xa5z*\xb6\xfe\\'
ciphertext = b'\xd1O\x14j\xa4+O\xb6\xa1\xc4\x08B)\x8f\x12\xdd'

s_box = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

inv_s_box = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

def expand_key(master_key):
    """
    Expands and returns a list of key matrices for the given master_key.
    """

    # Round constants https://en.wikipedia.org/wiki/AES_key_schedule#Round_constants
    r_con = (
        0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
        0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
        0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,
        0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39,
    )

    # Initialize round keys with raw key material.
    key_columns = bytes2matrix(master_key)
    iteration_size = len(master_key) // 4

    # Each iteration has exactly as many columns as the key material.
    i = 1
    while len(key_columns) < (N_ROUNDS + 1) * 4:
        # Copy previous word.
        word = list(key_columns[-1])

        # Perform schedule_core once every "row".
        if len(key_columns) % iteration_size == 0:
            # Circular shift.
            word.append(word.pop(0))
            # Map to S-BOX.
            word = [s_box[b] for b in word]
            # XOR with first byte of R-CON, since the others bytes of R-CON are 0.
            word[0] ^= r_con[i]
            i += 1
        elif len(master_key) == 32 and len(key_columns) % iteration_size == 4:
            # Run word through S-box in the fourth iteration when using a
            # 256-bit key.
            word = [s_box[b] for b in word]

        # XOR with equivalent word from previous iteration.
        word = bytes(i^j for i, j in zip(word, key_columns[-iteration_size]))
        key_columns.append(word)

    # Group key words in 4x4 byte matrices.
    return [key_columns[4*i : 4*(i+1)] for i in range(len(key_columns) // 4)]

def bytes2matrix(text):
    """ Converts a 16-byte array into a 4x4 matrix.  """
    return [list(text[i:i+4]) for i in range(0, len(text), 4)]

def matrix2bytes(matrix):
    """ Converts a 4x4 matrix into a 16-byte array.  """
    return b''.join(bytes([a]) for row in matrix for a in row)

def add_round_key(s, k):
    return [[s[i][j]^k[i][j] for j in range(4)] for i in range(4)]

def inv_shift_rows(s):
    s[1][1], s[2][1], s[3][1], s[0][1] = s[0][1], s[1][1], s[2][1], s[3][1]
    s[2][2], s[3][2], s[0][2], s[1][2] = s[0][2], s[1][2], s[2][2], s[3][2]
    s[3][3], s[0][3], s[1][3], s[2][3] = s[0][3], s[1][3], s[2][3], s[3][3]

# learned from http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c
xtime = lambda a: (((a << 1) ^ 0x1B) & 0xFF) if (a & 0x80) else (a << 1)

def mix_single_column(a):
    # see Sec 4.1.2 in The Design of Rijndael
    t = a[0] ^ a[1] ^ a[2] ^ a[3]
    u = a[0]
    a[0] ^= t ^ xtime(a[0] ^ a[1])
    a[1] ^= t ^ xtime(a[1] ^ a[2])
    a[2] ^= t ^ xtime(a[2] ^ a[3])
    a[3] ^= t ^ xtime(a[3] ^ u)

def mix_columns(s):
    for i in range(4):
        mix_single_column(s[i])

def inv_mix_columns(s):
    # see Sec 4.1.3 in The Design of Rijndael
    for i in range(4):
        u = xtime(xtime(s[i][0] ^ s[i][2]))
        v = xtime(xtime(s[i][1] ^ s[i][3]))
        s[i][0] ^= u
        s[i][1] ^= v
        s[i][2] ^= u
        s[i][3] ^= v
    mix_columns(s)

def sub_bytes(s, sbox=s_box):
    return [[int(sbox[a]) for a in row] for row in s]

def decrypt(key, ciphertext):
    round_keys = expand_key(key) # Remember to start from the last round key and work backwards through them when decrypting

    # Convert ciphertext to state matrix
    state = bytes2matrix(ciphertext)
    
    # Initial add round key step
    state = add_round_key(state, round_keys.pop())

    for i in range(N_ROUNDS - 1, 0, -1):
        # Do round
        inv_shift_rows(state)
        state = sub_bytes(state, sbox=inv_s_box)
        state = add_round_key(state, round_keys.pop())
        inv_mix_columns(state)

    # Run final round (skips the InvMixColumns step)
    inv_shift_rows(state)
    state = sub_bytes(state, sbox=inv_s_box)
    state = add_round_key(state, round_keys.pop())

    plaintext = matrix2bytes(state) # Convert state matrix to plaintext

    return plaintext

print(decrypt(key, ciphertext))

#SYMMETRIC STARTER
#Modes of Operation Starter 
#crypto{bl0ck_c1ph3r5_4r3_f457_!}
import requests

BASE_URL = "http://aes.cryptohack.org/block_cipher_starter"

# 1) get the ciphertext of the encrypted flag
r = requests.get(f"{BASE_URL}/encrypt_flag")
data = r.json()
ciphertext = data["ciphertext"]
print("ciphertext", ciphertext)

# 2) send the ciphertext to the decrypt function
r = requests.get(f"{BASE_URL}/decrypt/{ciphertext}")
data = r.json()
plaintext = data["plaintext"]
print("plaintext", plaintext)

# 3) convert from hex to ASCII to have the flag
print("flag", bytearray.fromhex(plaintext).decode())

#Passwords as Keys
#crypto{k3y5__r__n07__p455w0rdz?}
from Crypto.Cipher import AES
import hashlib
import random

wordlist = open('wordlist.txt') # https://gist.githubusercontent.com/wchargin/8927565/raw/d9783627c731268fb2935a731a618aa8e95cf465/words
wordlist = wordlist.read()
wordlist = wordlist.split('\n')


ciphertext = 'c92b7734070205bdf6c0087a751466ec13ae15e6f1bcdd3f3a535ec0f4bbae66' # Our ciphertext
ciphertext = bytes.fromhex(ciphertext) # encode ciphertext



for key in wordlist: # Our key
    key = hashlib.md5(key.encode()).digest() # encode key

    cipher = AES.new(key, AES.MODE_ECB)
    
    try:
        decrypted = cipher.decrypt(ciphertext) # encode flag
    except:
        pass
        
        
    # Try print the flag, else pass 
    try:
        
        print(bytearray.fromhex(decrypted.hex()).decode()) # decode flag |  
    except:
        pass

#BLOCK CIPHERS
#ECB CBC WTF
#crypto{p3n6u1n5_h473_3cb}
#import requests

url_base = 'http://aes.cryptohack.org/ecbcbcwtf'

BLOCK_SIZE = 16

def hack():
  response = requests.get(url="%s/encrypt_flag/" % url_base).json()
  ciphertext = response['ciphertext']
  
  response = requests.get(url="%s/decrypt/%s" % (url_base, ciphertext)).json()
  plaintext = bytes.fromhex(response['plaintext'])
  ciphertext = bytes.fromhex(ciphertext)

  flag = bytearray()
  for i in range((len(ciphertext)//BLOCK_SIZE)-1):
    flag.extend(bytearray(a ^ b for a, b in zip(ciphertext[i*BLOCK_SIZE:(i+1)*BLOCK_SIZE], plaintext[(i+1)*BLOCK_SIZE:(i+2)*BLOCK_SIZE])))
  return flag.decode()

if __name__ == '__main__':
  flag = hack()
  print(flag)

#ECB Oracle 
import requests
import string
import binascii,json

url='http://aes.cryptohack.org/ecb_oracle/encrypt/'

"""
Function for hex encoding
"""
def hex(p):
    return (binascii.hexlify(p.encode())).decode()

flag=''
input='A'*32 #Let's assume flag length is between 16-32
k=0
while k<33:
    for i in string.ascii_letters+string.digits+'{_}':
        r = requests.get(url+hex(input[:-1]))
        ref_block=json.loads(r.text)["ciphertext"][:64] #Reference block
        r = requests.get(url+hex(input[:-1]+flag+i))
        if json.loads(r.text)["ciphertext"][:64]==ref_block:
            flag+=i
            print("\r"+flag, flush=True, end='') #crypto{p3n6u1n5_h473_3cb}
            break
    k+=1
    input=input[:-1]

#Flipping Cookie
#crypto{4u7h3n71c4710n_15_3553n714l}
import requests
from Crypto.Util.number import long_to_bytes, bytes_to_long


def xor(a, b):
    return long_to_bytes(bytes_to_long(a) ^ bytes_to_long(b))

url = "https://aes.cryptohack.org/flipping_cookie/"
req = requests.get(url + "get_cookie/")
ciphertext = bytes.fromhex(req.json()['cookie'])
iv = ciphertext[:16]
block = ciphertext[16:]

original = b"admin=False;expi"
final = xor(original, iv)
first = b"admin=False;expi"
res = b"admin=True;expir"
print("xor hehe: ", xor(first, res))
iv = xor(xor(first, res), iv)
print(xor(iv, final))

req = requests.get(url + "check_admin/" + block.hex() + "/" + iv.hex() + "/")
print(req.json())

#Lazy CBC
#crypto{50m3_p30pl3_d0n7_7h1nk_IV_15_1mp0r74n7_?}
#import requests


def xorStrings(a, b):
    return bytes([a[i] ^ b[i] for i in range(len(a))])


url = "https://aes.cryptohack.org/lazy_cbc/"
ciphertext = b"\x00" * 32
req = requests.get(url + "receive/" + ciphertext.hex() + "/")
plaintext = req.json()["error"][len("Invalid plaintext: "):]
print(plaintext)
plaintext = bytes.fromhex(plaintext)
cp1 = plaintext[:16]
cp2 = plaintext[16:]

plaintext = xorStrings(cp1, cp2)

req = requests.get(url + "get_flag/" + plaintext.hex() + "/")
print(bytes.fromhex(req.json()["plaintext"]))

#Triple DES
#crypto{n0t_4ll_k3ys_4r3_g00d_k3ys}
import requests

url = "https://aes.cryptohack.org/triple_des/"

key = b'\x00' * 8 + b'\xff' * 8

r = requests.get(url + "encrypt_flag/" + key.hex() + "/")
cipher = r.json()["ciphertext"]
r = requests.get(url + "encrypt/" + key.hex() + "/" + cipher + "/")
print(bytes.fromhex(r.json()["ciphertext"]))
#----------------------------------------------------------------------------------------------------------------------------------
#STREAM CIPHERS
#Symmetry
#crypto{0fb_15_5ymm37r1c4l_!!!11!}
import requests

url_base = 'http://aes.cryptohack.org/symmetry'

BLOCK_SIZE = 16

def hack():
  response = requests.get(url="%s/encrypt_flag/" % url_base).json()
  ciphertext = bytes.fromhex(response['ciphertext'])

  # Split the ciphertext into the IV and the actual ciphertext
  iv, ciphertext = ciphertext[:BLOCK_SIZE], ciphertext[BLOCK_SIZE:]

  # Encrypt the ciphertext (E_K(IV) ^ FLAG) which just will encrypt the supplied
  # IV as E_K(IV) and XOR it with the ciphertext and recover the flag. Abuses
  # the fact that encryption and decryption perform the same operation in OFB mode.
  response = requests.get(url="%s/encrypt/%s/%s" % (url_base, ciphertext.hex(), iv.hex())).json()
  plaintext = bytes.fromhex(response['ciphertext'])
  return plaintext.decode()

if __name__ == '__main__':
  flag = hack()
  print(flag)
#--------------------------------------------------------------------------------
#Bean Counter
#crypto{hex_bytes_beans}
import requests
def encrypt():
    url = "http://aes.cryptohack.org/bean_counter/encrypt/"
    rsp = requests.get(url)
    return rsp.json()['encrypted']

png_hdr = bytes([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 0x49, 0x48, 0x44, 0x52])
encrypted = bytes.fromhex(encrypt())

keystream = []
for i in range(len(png_hdr)):
    keystream.append(png_hdr[i] ^ encrypted[i])

print(keystream)

png = [0] * len(encrypted)
for i in range(len(encrypted)):
    png[i] = encrypted[i] ^ keystream[i % len(keystream)]

with open('bean_counter.png', 'wb') as fd:
    fd.write(bytes(png))

#CTRIME-------------------------------------------------------------------
#crypto{CRIME_571ll_p4y5}
import requests, sys

solution = "crypto{"
chars = 'ABCDEFGHIJKLMNOPQRTSUVWXYZ0123456789_abcdefghijklmnopqrstuvwxyz}'
invalid_char = ';'

while True:
    p = (solution + invalid_char) * 2
    r = requests.get("https://aes.cryptohack.org/ctrime/encrypt/" + p.encode('ascii').hex()).json()
    sample = len(r['ciphertext'])
    for c in chars:
        r = requests.get(
            "https://aes.cryptohack.org/ctrime/encrypt/" + ((solution + c) * 2).encode('ascii').hex()).json()
        if len(r['ciphertext']) < sample:
            solution += c
            print(solution)
            if c == "}":
                print("Solution Found!", solution)
                sys.exit()
            break

#Logon Zero----------------------------------------------------------------------------
#crypto{Zerologon_Windows_CVE-2020-1472}
import json
from pwn import *

address = ("socket.cryptohack.org", 13399)
conn = remote(address[0], address[1])

print(conn.recvline().decode())

token = b"\x00" * 28
resetPasswordCommand = json.dumps({"option": "reset_password", "token": token.hex()}).encode()
authCommand = json.dumps({"option": "authenticate", "password": ""}).encode()
resetCommand = json.dumps({"option": "reset_connection"}).encode()

while True:

    conn.sendline(resetPasswordCommand)
    conn.recvline().decode()

    conn.sendline(authCommand)
    ans = conn.recvline().decode()
    if "crypto" in ans:
        print(ans)
        conn.close()
        exit(0)

    print(ans)
    conn.sendline(resetCommand)
    conn.recvline().decode()

#Stream of Consciousness----------------------------------------------
#crypto{k3y57r34m_r3u53_15_f474l}
import requests, os

print("Collecting ciphertexts...")
ciphertexts = []
for i in range(50):
    ct = requests.get('http://aes.cryptohack.org/stream_consciousness/encrypt/').json()['ciphertext']
    if not ct in ciphertexts:
        ciphertexts.append(ct)

def xor_all(ciphertexts, key):
    # Check if the key is valid for all ciphertexts
    for ct in ciphertexts:
        ct = bytes.fromhex(ct)
        for i in range(len(key)):
            if i >= len(ct):
                break
            a = key[i] ^ ct[i]
            if not (a > 31 and a < 127):
                return False
    return True

key = []
encrypted_flag = ""
for ct in ciphertexts:
    c = bytes.fromhex(ct)
    keys = []
    for i in range(len(b'crypto{')):
        keys.append(b'crypto{'[i] ^ c[i]) 
    if xor_all(ciphertexts, keys):
        key[:] = keys[:]
        encrypted_flag = ct
        break
    if key:
        break


def guess(key):
    os.system("clear")
    for i in range(len(ciphertexts)):
        print(i, end=": ")
        for j in range(len(key)):
            if j >= len(bytes.fromhex(ciphertexts[i])):
                break
            print(chr(key[j] ^ bytes.fromhex(ciphertexts[i])[j]), end="")
        print()
    index = int(input("choose a plaintext to guess: "))
    guess = input("enter the next characters of the plaintext: ")
    os.system("clear")
    tmp_key = key[:]
    for i in range(len(guess)):
        tmp_key.append(ord(guess[i]) ^ bytes.fromhex(ciphertexts[index])[len(tmp_key)])
    for i in range(len(ciphertexts)):
        print(i, end=": ")
        for j in range(len(tmp_key)):
            if j >= len(bytes.fromhex(ciphertexts[i])):
                break
            print(chr(tmp_key[j] ^ bytes.fromhex(ciphertexts[i])[j]), end="")
        print()
    isok = input("correct text? y/n: ")
    if isok.upper() == "Y":
        key = tmp_key
while True:
    guess(key)

#Dancing Queen
#-------------------------------------------------------------
#crypto{M1x1n6_r0und5_4r3_1nv3r71bl3!}
def bytes_to_words(b):
    return [int.from_bytes(b[i:i+4], 'little') for i in range(0, len(b), 4)]

def rotate(x, n):
    return ((x << n) & 0xffffffff) | ((x >> (32 - n)) & 0xffffffff)

def word(x):
    return x % (2 ** 32)

def words_to_bytes(w):
    return b''.join([i.to_bytes(4, 'little') for i in w])

def xor(a, b):
    return b''.join([bytes([x ^ y]) for x, y in zip(a, b)])


class ChaCha20:
	def __init__(self):
		self._state = []

	def _inner_block(self, state):
		self._quarter_round(state, 0, 4, 8, 12)
		self._quarter_round(state, 1, 5, 9, 13)
		self._quarter_round(state, 2, 6, 10, 14)
		self._quarter_round(state, 3, 7, 11, 15)
		self._quarter_round(state, 0, 5, 10, 15)
		self._quarter_round(state, 1, 6, 11, 12)
		self._quarter_round(state, 2, 7, 8, 13)
		self._quarter_round(state, 3, 4, 9, 14)
	def reverse_inner_block(self, state):
		self.reverse_quarter_round(state, 3, 4, 9, 14)
		self.reverse_quarter_round(state, 2, 7, 8, 13)
		self.reverse_quarter_round(state, 1, 6, 11, 12)
		self.reverse_quarter_round(state, 0, 5, 10, 15)
		self.reverse_quarter_round(state, 3, 7, 11, 15)
		self.reverse_quarter_round(state, 2, 6, 10, 14)
		self.reverse_quarter_round(state, 1, 5, 9, 13)
		self.reverse_quarter_round(state, 0, 4, 8, 12)

	def _quarter_round(self, x, a, b, c, d):
		x[a] = word(x[a] + x[b]); x[d] ^= x[a]; x[d] = rotate(x[d], 16)
		x[c] = word(x[c] + x[d]); x[b] ^= x[c]; x[b] = rotate(x[b], 12)
		x[a] = word(x[a] + x[b]); x[d] ^= x[a]; x[d] = rotate(x[d], 8)
		x[c] = word(x[c] + x[d]); x[b] ^= x[c]; x[b] = rotate(x[b], 7)
	def reverse_quarter_round(self,x, a, b, c, d):
		x[b] = rotate(x[b], 32-7)
		x[b] ^= x[c]
		x[c] = word(x[c] - x[d])
		x[d] = rotate(x[d], 32-8)
		x[d] ^= x[a]
		x[a] = word(x[a] - x[b])
		x[b] = rotate(x[b], 32-12)
		x[b] ^= x[c]
		x[c] = word(x[c] - x[d])
		x[d] = rotate(x[d], 32-16)
		x[d] ^= x[a]
		x[a] = word(x[a] - x[b])
    
	def _setup_state(self, key, iv):
		self._state = [0x61707865, 0x3320646e, 0x79622d32, 0x6b206574]
		self._state.extend(bytes_to_words(key))
		self._state.append(self._counter)
		self._state.extend(bytes_to_words(iv))

	def decrypt(self, c, key, iv):
		return self.encrypt(c, key, iv)

	def encrypt(self, m, key, iv):
		c = b''
		self._counter = 1

		for i in range(0, len(m), 64):
			self._setup_state(key, iv)
			for j in range(10):
				self._inner_block(self._state)
			c += xor(m[i:i+64], words_to_bytes(self._state))

			self._counter += 1

		return c
	def recover_state(self,m,ct):
		self._state = bytes_to_words(xor(m[:64],ct[:64])[:64])
		for j in range(10):
			self.reverse_inner_block(self._state)
		key = words_to_bytes(self._state[4:])[:32]
		return key


if __name__ == '__main__':
    msg = b'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aenean commodo ligula.'
    iv1 = bytes.fromhex('e42758d6d218013ea63e3c49')
    iv2 = bytes.fromhex('a99f9a7d097daabd2aa2a235')
    msg_enc = bytes.fromhex('f3afbada8237af6e94c7d2065ee0e221a1748b8c7b11105a8cc8a1c74253611c94fe7ea6fa8a9133505772ef619f04b05d2e2b0732cc483df72ccebb09a92c211ef5a52628094f09a30fc692cb25647f')
    flag_enc = bytes.fromhex('b6327e9a2253034096344ad5694a2040b114753e24ea9c1af17c10263281fb0fe622b32732')


    c = ChaCha20()

    key = c.recover_state(msg,msg_enc)
    print(c.decrypt(flag_enc,key,iv2))

#Oh SNAP
#-------------------------------------------------------------
from Crypto.Cipher import ARC4
from Crypto.Util.number import *
from tqdm import tqdm
import requests
from Crypto.Util.Padding import unpad

# function to swap two values in the box.
def swapValueByIndex(box, i, j):
    temp = box[i]
    box[i] = box[j]
    box[j] = temp


# Initialize S-box.
def initSBox(box):
    if len(box) == 0:
        for i in range(256):
            box.append(i)
    else:
        for i in range(256):
            box[i] = i


def send_cmd(ciphertext, nonce):
    res = requests.get(f"http://aes.cryptohack.org/oh_snap/send_cmd/{ciphertext.hex()}/{nonce.hex()}/")
    return res.json()


key = [None] * 3
print(key)
for i1 in tqdm(range(len(key) - 3, 34)):
    prob = [0] * 256
    for i2 in tqdm(range(256)):
        key[0] = i1 + 3
        key[1] = 255
        key[2] = i2
        j = 0
        box = []
        initSBox(box)
        # Simulate the S-Box after KSA initialization.
        for i in tqdm(range(key[0])):
            j = (j + box[i] + key[i]) % 256
            swapValueByIndex(box, i, j)
            # Record the original box[0] and box[1] value.
            if i == 1:
                original0 = box[0]
                original1 = box[1]
        i = key[0]  # A+3
        z = box[1]  # 0

        # if resolved condition is possibly met.
        if z + box[z] == key[0]:
            # If the value of box[0] and box[1] has changed, discard this possibility.
            if original0 != box[0] or original1 != box[1]:
                continue
            nonce = long_to_bytes(key[0]) + long_to_bytes(key[1]) + long_to_bytes(key[2])
            a = send_cmd(b'\x00', nonce)['error']
            keyStreamByte = int(a.split(': ')[1], 16)
            keyByte = (box.index(keyStreamByte) - j - box[i]) % 256
            prob[keyByte] += 1
        # Assuming the most hit is the correct password.
        mostHit = prob.index(max(prob))
    key.append(mostHit)
    for i in key[3:]:
        print(chr(i), end="")

for i in key[3:]:
    print(chr(i), end="")
